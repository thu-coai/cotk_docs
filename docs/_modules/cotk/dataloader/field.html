

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cotk.dataloader.field &mdash; cotk  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/cotk_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> cotk
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/tutorial_core.html">Practice: Implement a GRU Language Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/cli_usage.html">CLI Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/extend.html">Extending Cotk: More Data, More Metrics!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/FAQ.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">Package Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dataloader.html">Data Loader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wordvector.html">Word Vector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metric.html">Metric</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file_utils.html">file_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../file_utils.html#resources-processor">resources_processor</a></li>
</ul>
<p class="caption"><span class="caption-text">Model Zoo</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models/LanguageGeneration/index.html">LanguageGeneration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/SingleTurnDialog/index.html">SingleTurnDialog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/MultiTurnDialog/index.html">MultiTurnDialog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cotk</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>cotk.dataloader.field</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cotk.dataloader.field</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;A module for field&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.._utils</span> <span class="kn">import</span> <span class="n">trim_before_target</span><span class="p">,</span> <span class="n">chain_sessions</span><span class="p">,</span> <span class="n">restore_sessions</span><span class="p">,</span> <span class="n">is_build_private_docs</span>
<span class="kn">from</span> <span class="nn">.._utils.metaclass</span> <span class="kn">import</span> <span class="n">DocStringInheritor</span><span class="p">,</span> <span class="n">LoadClassInterface</span><span class="p">,</span> <span class="n">copy_func</span><span class="p">,</span> <span class="n">copy_property</span>
<span class="kn">from</span> <span class="nn">.._utils.unordered_hash</span> <span class="kn">import</span> <span class="n">UnorderedSha256</span><span class="p">,</span> <span class="n">dumps</span>
<span class="kn">from</span> <span class="nn">.tokenizer</span> <span class="kn">import</span> <span class="n">SimpleTokenizer</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span>
<span class="kn">from</span> <span class="nn">.vocab</span> <span class="kn">import</span> <span class="n">Vocab</span><span class="p">,</span> <span class="n">GeneralVocab</span><span class="p">,</span> <span class="n">PretrainedVocab</span><span class="p">,</span> <span class="n">SimpleVocab</span>
<span class="kn">from</span> <span class="nn">.context</span> <span class="kn">import</span> <span class="n">FieldContext</span>

<span class="n">RawSentenceType</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">TokenizedSentenceType</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">RawSessionType</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">RawSentenceType</span><span class="p">]</span>
<span class="n">TokenizedSessionType</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">TokenizedSentenceType</span><span class="p">]</span>

<div class="viewcode-block" id="Field"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Field">[docs]</a><span class="k">class</span> <span class="nc">Field</span><span class="p">(</span><span class="n">LoadClassInterface</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">DocStringInheritor</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;A base class of data field, which specify the format of the dataset.</span>
<span class="sd">	See :ref:`Field&lt;field_ref&gt;` and :ref:`building a dataloader of customized task&lt;customized_tasks_ref&gt;` for usages.</span>

<span class="sd">	Notice :class:`Field` object may be shared between different fields, data sets or dataloader.</span>
<span class="sd">	Thus it only defines settings and do NOT stores data.</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">NOT_SPECIFIED_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">	If any argument is not specified,</span>
<span class="s1">	the value will be first retrieved from :class:`FieldContext`. If still ``None``, default</span>
<span class="s1">	value will be used.</span>
<span class="s1">	&#39;&#39;&#39;</span>

	<span class="k">if</span> <span class="n">is_build_private_docs</span><span class="p">():</span>
		<span class="vm">__doc__</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;The data is exactly stored in :class:`_FieldContent`.&quot;&quot;&quot;</span>

	<span class="n">DEFAULT_VOCAB_FROM_MAPPINGS</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s2">&quot;train&quot;</span><span class="p">:</span> <span class="s2">&quot;train&quot;</span><span class="p">,</span>
		<span class="s2">&quot;training&quot;</span><span class="p">:</span> <span class="s2">&quot;train&quot;</span><span class="p">,</span>
		<span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
		<span class="s2">&quot;development&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
		<span class="s2">&quot;valid&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
		<span class="s2">&quot;validation&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
		<span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
		<span class="s2">&quot;evaluation&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span>
	<span class="p">}</span>
	<span class="sd">&#39;&#39;&#39;Dict[str, str]:</span>
<span class="sd">			Infer the set type (train, test, or extra)</span>
<span class="sd">			from the set name. For example, ``DEFAULT_VOCAB_FROM_MAPPINGS[&quot;dev&quot;] == &quot;test&quot;`` means that the words from the &quot;dev&quot; set</span>
<span class="sd">			is used for test.</span>
<span class="sd">	&#39;&#39;&#39;</span>

<div class="viewcode-block" id="Field.get_vocab"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Field.get_vocab">[docs]</a>	<span class="k">def</span> <span class="nf">get_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Get :class:`Vocab` object for the field. ``None`` if the field do not have a :class:`Vocab`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Field.get_tokenizer"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Field.get_tokenizer">[docs]</a>	<span class="k">def</span> <span class="nf">get_tokenizer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tokenizer</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Get :class:`Tokenizer` object for the field. ``None`` if the field do not have a :class:`Tokenizer`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="kc">None</span></div>

	<span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_FieldContent&quot;</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Create a :class:`_FieldContent` to store data which have been read.</span>

<span class="sd">		Arguments:</span>
<span class="sd">			set_name (str): specify the set name for the :class:`_FieldContent`, which may affect the vocab type.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

	<span class="k">def</span> <span class="nf">_get_setting_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocabs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Get setting hash for the field. ``vocabs`` are provided by :class:`LanguageProcessing`.</span>
<span class="sd">		This function only encode index of vocab, and other settings. It only encode index because</span>
<span class="sd">		encode the setting hash of vocabs cannot explain whether a :class:`Vocab` is shared between different vocabs or not.</span>

<span class="sd">		Arguments:</span>
<span class="sd">			vocabs (list): list of :class:`Vocab`.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

	<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;data (Any): the data stored in dataloader.&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">is_build_private_docs</span><span class="p">():</span>
		<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="s2">&quot;data (Any): the data returned by :meth:`_FieldContent.get_data`.&quot;</span>

	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<div class="viewcode-block" id="Field.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Field.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Invoked by :meth:`LanguageProcessing.get_batch`, return the batched data specified by this field.</span>
<span class="sd">		This function is for INTERNAL USE only, but it shows the data format of the returned batch.</span>

<span class="sd">		{_GET_BATCH_RETURN_VALUE}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			name (str): name of the field.</span>
<span class="sd">			{_GET_BATCH_DATA_DOCSTRING}</span>
<span class="sd">			indexes (List[int]): the indexes of the data in this batch</span>

<span class="sd">		{_GET_BATCH_EXAMPLE}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>

<span class="k">class</span> <span class="nc">_FieldContent</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">DocStringInheritor</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Store the content data of a field.</span>
<span class="sd">		Different from :class:`Field`, it won&#39;t be shared between fields or dataloader,</span>
<span class="sd">		and it can save data.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span><span class="p">:</span> <span class="nb">str</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span><span class="p">:</span> <span class="nb">str</span>

	<span class="n">_GET_NEXT_ARG</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			dataset (Iterator[str]): An iterator of the data file content.</span>
<span class="s2">				Generally, each element is a string, that ends with &#39;\n&#39;.</span>
<span class="s2">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">_get_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Read the next data from ``dataset`` and returns a 2-tuple (the data, and the number of elements it read from `dataset`).</span>

<span class="sd">		Arguments:{_GET_NEXT_ARG}</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

	<span class="k">def</span> <span class="nf">read_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Read the next element from ``dataloader`` and store the elements.</span>
<span class="sd">		Returns the number of lines read.</span>

<span class="sd">		Arguments:</span>
<span class="sd">			dataset (Iterator[str]): An iterator of the data file.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;read_next must be called before get_data&quot;</span><span class="p">)</span>
		<span class="n">sent</span><span class="p">,</span> <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">lines</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lines</span>

	<span class="k">def</span> <span class="nf">process_before_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;This function is called after all elements read, but before building vocabulary.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

	<span class="k">def</span> <span class="nf">get_data_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Get the number of elements in this field.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Get the data, which will be stored in the :class:`LanguageProcessing`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

	<span class="k">def</span> <span class="nf">get_raw_data_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Return the raw data hash of this field content.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span>

	<span class="k">def</span> <span class="nf">get_data_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Return the data hash of this field content.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span>

<span class="k">class</span> <span class="nc">_SentenceContent</span><span class="p">(</span><span class="n">_FieldContent</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Store the content data of :class:`Sentence` field.</span>
<span class="sd">		Different from :class:`Field`, it won&#39;t be shared between fields or dataloader,</span>
<span class="sd">		and it can save data.</span>

<span class="sd">	Arguments:</span>
<span class="sd">		field (Sentence): The corresponding field of this content.</span>
<span class="sd">		vocab_from (str): The type of vocab, must be one of [&quot;train&quot;, &quot;test&quot;, &quot;extra&quot;, &quot;default&quot;]</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="s2">&quot;Sentence&quot;</span><span class="p">,</span> <span class="n">vocab_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab_from</span> <span class="o">=</span> <span class="n">vocab_from</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_get_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&quot;&quot;&quot;read the next sentence and returns a 2-tuple (the sentence and number of elements it reads from `dataset`).</span>
<span class="sd">		Note that it may raise StopIteration.</span>

<span class="sd">		Arguments:{_FieldContent._GET_NEXT_ARG}</span>

<span class="sd">		Examples:</span>
<span class="sd">			&gt;&gt;&gt; dataset = iter([&quot;I love NLP.\\n&quot;, &quot;Yes I do\\n&quot;, &quot;I love deep learning\\n&quot;])</span>
<span class="sd">			&gt;&gt;&gt; field_content = _SentenceContent(&quot;Sentence&quot;, &quot;test&quot;)</span>
<span class="sd">			&gt;&gt;&gt; field_content._get_next(dataset)</span>
<span class="sd">			&quot;I love NLP&quot;, 1</span>
<span class="sd">			&gt;&gt;&gt; field_content._get_next(dataset)</span>
<span class="sd">			&quot;Yes I do&quot;, 1</span>
<span class="sd">			&gt;&gt;&gt; field_content._get_next(dataset)</span>
<span class="sd">			&quot;I love deep learning&quot;, 1</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(),</span> <span class="mi">1</span>

	<span class="k">def</span> <span class="nf">process_before_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">raw_data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">:</span>
			<span class="n">raw_data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span> <span class="o">=</span> <span class="n">raw_data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span> <span class="o">=</span> <span class="n">tokenized_sents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">tokenize_sentences</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">)</span>

		<span class="n">data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">tokenized_sent</span> <span class="ow">in</span> <span class="n">tokenized_sents</span><span class="p">:</span>
			<span class="n">data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">tokenized_sent</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span> <span class="o">=</span> <span class="n">data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">get_vocab</span><span class="p">()</span><span class="o">.</span><span class="n">add_tokens</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">tokenized_sents</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab_from</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="c1"># allvocabs</span>
		<span class="n">id_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">process_sentences</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">id_data</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">}</span>

	<span class="k">if</span> <span class="n">is_build_private_docs</span><span class="p">():</span>
		<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="s1">&#39;data (Dict[str, Any]): the object returned by :meth:`_SentenceContent.get_data`. &#39;</span>\
			<span class="s2">&quot;data[&#39;str&#39;] is raw sentences. data[&#39;id&#39;] is the ids of tokenized sentences.&quot;</span>


<span class="k">class</span> <span class="nc">_InfiniteLength</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;Infinite length. A special value for `max_sent_length` and `max_turn_length`, which means that the sent_length</span>
<span class="sd">	and turn_length is unlimited.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">__instance</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="c1"># Singleton</span>
		<span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__instance</span>
		<span class="k">return</span> <span class="n">obj</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s1">&#39;INFINITE_LENGTH&#39;</span>

	<span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span>

<div class="viewcode-block" id="Sentence"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence">[docs]</a><span class="k">class</span> <span class="nc">Sentence</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Field`</span>

<span class="sd">	A field for sentence. This class is a virtual class and the base of</span>
<span class="sd">	:class:`Sentence`, :class:`SentenceGPT2` and :class:`SentenceBERT`.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SENTENCE_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">	</span><span class="si">{Field.NOT_SPECIFIED_DOCS}</span><span class="s1"></span>

<span class="s1">	Arguments:</span>
<span class="s1">			</span><span class="si">{Sentence.TOKENIZER_DOCS}</span><span class="s1"> </span><span class="si">{Sentence.TOKENIZER_DEFAULT}</span><span class="s1"></span>
<span class="s1">			</span><span class="si">{Sentence.VOCAB_DOCS}</span><span class="s1"> </span><span class="si">{Sentence.VOCAB_DEFAULT}</span><span class="s1"></span>
<span class="s1">			</span><span class="si">{Sentence.VOCAB_FROM_MAPPINGS_DOCS}</span><span class="s1"> </span><span class="si">{Sentence.VOCAB_FROM_MAPPINGS_DEFAULT}</span><span class="s1"></span>
<span class="s1">			</span><span class="si">{Sentence.MAX_SENT_LENGTH_DOCS}</span><span class="s1"> </span><span class="si">{Sentence.MAX_SENT_LENGTH_DEFAULT}</span><span class="s1"></span>
<span class="s1">			</span><span class="si">{Sentence.CONVERT_TO_LOWER_LETTER_DOCS}</span><span class="s1"> </span><span class="si">{Sentence.CONVERT_TO_LOWER_LETTER_DEFAULT}</span><span class="s1"></span>
<span class="s1">		&#39;&#39;&#39;</span>

	<span class="n">SENTENCE_INPUT_FORMAT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	Input Formats</span>
<span class="s2">		This field read one line of sentence per sample.</span>
<span class="s2">	&quot;&quot;&quot;</span>

	<span class="n">TOKENIZER_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			tokenizer (:class:`Tokenizer`, str, optional): How to tokenize sentence. if ``str``, see :ref:`tokenizer&lt;tokenizer_ref&gt;` for</span>
<span class="s2">					possible value.&quot;&quot;&quot;</span>
	<span class="n">TOKENIZER_DEFAULT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;No default value, ``KeyError`` will be raised.&#39;&#39;&#39;</span>
	<span class="n">VOCAB_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			vocab (:class:`Vocab`, optional):The vocabulary used for this field. Sharing this object between fields can</span>
<span class="s2">					build vocabulary together. &quot;&quot;&quot;</span>
	<span class="n">VOCAB_DEFAULT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;No default value, ``KeyError`` will be raised.&#39;&#39;&#39;</span>
	<span class="n">VOCAB_FROM_MAPPINGS_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			vocab_from_mappings (Dict[str, str], optional): Infer the set type (train, test, or extra) from the set name.</span>
<span class="s2">				For example, ``DEFAULT_VOCAB_FROM_MAPPINGS[&quot;dev&quot;] == &quot;test&quot;`` means that the words from the &quot;dev&quot; set</span>
<span class="s2">				is used for test.&quot;&quot;&quot;</span>
	<span class="n">VOCAB_FROM_MAPPINGS_DEFAULT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;Default: See :ref:`the table&lt;vocab_from_ref&gt;` for default value.&quot;&quot;&quot;</span>
	<span class="n">MAX_SENT_LENGTH_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">			max_sent_length (int, _InfiniteLength, optional): All sentences longer than ``max_sent_length`` will be shortened</span>
<span class="s1">					to first ``max_sent_length`` tokens. If it&#39;s ``None`` or ``Sentence.INFINITE_LENGTH``, sentences won&#39;t be</span>
<span class="s1">					shortened no matter how long they are.&#39;&#39;&#39;</span>
	<span class="n">MAX_SENT_LENGTH_DEFAULT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;Default: ``None``.&#39;&#39;&#39;</span>
	<span class="n">CONVERT_TO_LOWER_LETTER_DOCS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">			convert_to_lower_letter (bool, optional): Whether convert all the tokens to lower case after tokenization.&#39;&#39;&#39;</span>
	<span class="n">CONVERT_TO_LOWER_LETTER_DEFAULT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;&#39;&#39;Default: ``False``.&#39;&#39;&#39;</span>

	<span class="n">INFINITE_LENGTH</span> <span class="o">=</span> <span class="n">_InfiniteLength</span><span class="p">()</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Sentence&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Sentence is an abstract class, use SentenceDefault instead.&quot;</span><span class="p">)</span>

		<span class="k">with</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span>\
				<span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">,</span>\
				<span class="n">vocab</span><span class="o">=</span><span class="n">vocab</span><span class="p">,</span>\
				<span class="n">vocab_from_mappings</span><span class="o">=</span><span class="n">vocab_from_mappings</span><span class="p">,</span>\
				<span class="n">max_sent_length</span><span class="o">=</span><span class="n">max_sent_length</span><span class="p">,</span>\
				<span class="n">convert_to_lower_letter</span><span class="o">=</span><span class="n">convert_to_lower_letter</span><span class="p">):</span>
			<span class="n">filled_tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tokenizer&quot;</span><span class="p">,</span> <span class="n">no_default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">Vocab</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vocab&quot;</span><span class="p">,</span> <span class="n">no_default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vocab_from_mappings&quot;</span><span class="p">,</span> <span class="n">Field</span><span class="o">.</span><span class="n">DEFAULT_VOCAB_FROM_MAPPINGS</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_sent_length&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;convert_to_lower_letter&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span> <span class="o">==</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INFINITE_LENGTH</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># max_sent_length is used for slice. So, None means that sent_length is unlimited.</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">:</span> <span class="n">Tokenizer</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filled_tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">SimpleTokenizer</span><span class="p">(</span><span class="n">filled_tokenizer</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filled_tokenizer</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">filled_tokenizer</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown tokenizer type&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SentenceContent</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_SentenceContent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab_from_mappings</span><span class="p">[</span><span class="n">set_name</span><span class="p">])</span>
		<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Unknown set_name </span><span class="si">%s</span><span class="s2">, do not specify in the vocab_from_mappings&quot;</span> <span class="o">%</span> <span class="n">set_name</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">get_pretrained_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pretrained</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">{</span>
			<span class="s2">&quot;gpt2&quot;</span><span class="p">:</span> <span class="n">SentenceGPT2</span><span class="p">,</span>
			<span class="s2">&quot;bert&quot;</span><span class="p">:</span> <span class="n">SentenceBERT</span>
		<span class="p">}[</span><span class="n">pretrained</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">get_tokenizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span>

	<span class="k">def</span> <span class="nf">get_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span>

	<span class="k">def</span> <span class="nf">_get_setting_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocabs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span>
			<span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> \
				<span class="c1">#tokenizer_id, \</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">get_setting_hash</span><span class="p">(),</span> \
				<span class="n">vocabs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">),</span> \
				<span class="c1">#self.vocab.get_setting_hash(), \</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">vocab_from_mappings</span><span class="p">,</span> \
				<span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span><span class="p">,</span> \
				<span class="bp">self</span><span class="o">.</span><span class="n">convert_to_lower_letter</span> \
			<span class="p">]))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

	<span class="n">_SENTENCE_MORE_DOCSTRING</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<div class="viewcode-block" id="Sentence.tokenize_sentences"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.tokenize_sentences">[docs]</a>	<span class="k">def</span> <span class="nf">tokenize_sentences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
		<span class="sd">&#39;&#39;&#39;Tokenize ``sentences``.</span>
<span class="sd">		</span>
<span class="sd">		{_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		* Convert tokens to lower case if ``self.convert_to_lower_letter`` is ``True``.</span>
<span class="sd">		</span>

<span class="sd">		Arguments:</span>
<span class="sd">			sentences (List[str]): The list of sentence to be tokenized.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">tokenized_sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize_sentences</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_lower_letter</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[[</span><span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">]</span> <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">tokenized_sentences</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">tokenized_sentences</span></div>

<div class="viewcode-block" id="Sentence.tokenize"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.tokenize">[docs]</a>	<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Tokenize ``sentence``.</span>

<span class="sd">		{_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		* Convert tokens to lower case if ``self.convert_to_lower_letter`` is ``True``.</span>
<span class="sd">		</span>

<span class="sd">		Arguments:</span>
<span class="sd">			sentence (str): The sentence to be tokenized.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">tokenized_sentence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_lower_letter</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenized_sentence</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">tokenized_sentence</span></div>

	<span class="n">CONVERT_TO_ID_ARG</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			add_special (bool, optional): If ``True``, special tokens (e.g. ``go``, ``eos``) are added. Default: ``False``.</span>
<span class="s2">			only_frequent_word (bool, optional): If ``True``, rare vocabs will be replaced by ``unk_id``. Default: ``False``.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Sentence.convert_tokens_to_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.convert_tokens_to_ids">[docs]</a>	<span class="k">def</span> <span class="nf">convert_tokens_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">add_special</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Convert list of tokens to list of ids. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			tokens (List[str]): The tokens to be converted.{CONVERT_TO_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="n">only_frequent_word</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">add_special</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_special_to_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ids</span></div>

	<span class="n">CONVERT_FROM_ID_ARG</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			remove_special (bool, optional): If ``True``, detect and try to do a reverse operation of ``add_special`` in :meth:`convert_tokens_to_ids`.</span>
<span class="s2">					It will not remove ``unk`` or special tokens in the middle of sentences.</span>
<span class="s2">					Default: ``True``.</span>
<span class="s2">			trim (bool, optional): If ``True``, use :meth:`trim_in_ids` to remove trailing ``pad`` and ``eos``. Default: ``True``.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Sentence.convert_ids_to_tokens"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.convert_ids_to_tokens">[docs]</a>	<span class="k">def</span> <span class="nf">convert_ids_to_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Convert list of ids to list of tokens. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): The ids to be converted.{CONVERT_FROM_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">convert_ids_to_tokens</span><span class="p">(</span>\
				<span class="bp">self</span><span class="o">.</span><span class="n">remove_special_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">remove_special</span><span class="o">=</span><span class="n">remove_special</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">))</span></div>

<div class="viewcode-block" id="Sentence.convert_ids_to_sentence"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.convert_ids_to_sentence">[docs]</a>	<span class="k">def</span> <span class="nf">convert_ids_to_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;Convert list of tokens to a sentence. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): The ids to be converted.{CONVERT_FROM_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_ids_to_tokens</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">remove_special</span><span class="o">=</span><span class="n">remove_special</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">convert_tokens_to_sentence</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sentence.convert_sentence_to_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.convert_sentence_to_ids">[docs]</a>	<span class="k">def</span> <span class="nf">convert_sentence_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">add_special</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Convert a sentence to a list of ids. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			sentence (str): The sentence to be converted.{CONVERT_TO_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_sentences</span><span class="p">([</span><span class="n">sentence</span><span class="p">],</span> <span class="n">add_special</span><span class="o">=</span><span class="n">add_special</span><span class="p">,</span> \
				<span class="n">only_frequent_word</span><span class="o">=</span><span class="n">only_frequent_word</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sentence.add_special_to_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.add_special_to_ids">[docs]</a>	<span class="k">def</span> <span class="nf">add_special_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Add special tokens, such as ``go_id`` or ``eos_id`` to the input ``ids``. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): The input ids.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

	<span class="n">REMOVE_SPECIAL_ARG</span> <span class="o">=</span> <span class="n">CONVERT_FROM_ID_ARG</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:meth:`convert_tokens_to_ids()`&quot;</span><span class="p">,</span> <span class="s2">&quot;:meth:`add_special_to_ids`&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="Sentence.remove_special_in_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.remove_special_in_ids">[docs]</a>	<span class="k">def</span> <span class="nf">remove_special_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Remove special ids in input `ids`. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): Input ids.{CONVERT_FROM_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

	<span class="n">PROCESS_ARG</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">			add_special (bool, optional): If ``True``, special tokens (e.g. ``go``, ``eos``) are added. Default: ``True``.</span>
<span class="s2">			only_frequent_word (bool, optional): If ``True``, rare vocabs will be replaced by ``unk_id``. Default: ``False``.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Sentence.process_sentences"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.process_sentences">[docs]</a>	<span class="k">def</span> <span class="nf">process_sentences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span>
						  <span class="n">add_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
						  <span class="n">only_frequent_word</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
						  <span class="n">cut</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
		<span class="sd">&#39;&#39;&#39;Process input sentences.</span>

<span class="sd">		{_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		* If sentences haven&#39;t been tokenized, tokenize them by invoking :meth:`Sentence.tokenize_sentences`.</span>
<span class="sd">		* Then, convert the list of tokens to a list of ids.</span>
<span class="sd">		* If ``self.max_sent_length`` is not ``None`` and ``cut`` is ``True``,</span>
<span class="sd">		  sentences, whose length are more than ``self.max_sent_length``, are</span>
<span class="sd">		  shorten to first ``self.max_sent_length`` tokens.</span>

<span class="sd">		</span>

<span class="sd">		Arguments:</span>
<span class="sd">			sentences (List[str], List[List[str]]): `sentences` can be a list of sentences or a list of lists of tokens.</span>
<span class="sd">			{PROCESS_ARG}</span>
<span class="sd">			cut (bool, optional): Whether to cut sentences with too many tokens. Default: ``True``.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c1"># sentences: : Union[List[str], List[List[str]]]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">sentences</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sentences must not be empty.&quot;</span><span class="p">)</span>
		<span class="c1"># list of sentences</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sentences</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
			<span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize_sentences</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="n">sentences</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sentences[0] must not be an empty string.&quot;</span><span class="p">)</span>

		<span class="c1"># list of list of str</span>
		<span class="n">sentences</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">add_special</span><span class="o">=</span><span class="n">add_special</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="n">only_frequent_word</span><span class="p">)</span> <span class="k">for</span> <span class="n">tokens</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
		<span class="c1"># list of list of id</span>

		<span class="k">if</span> <span class="n">cut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">before_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
			<span class="n">sentences</span> <span class="o">=</span> <span class="p">[</span><span class="n">sentence</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sent_length</span><span class="p">]</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
			<span class="n">after_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;max length before cut: </span><span class="si">%d</span><span class="s2">, cut percent: </span><span class="si">%.2f%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="nb">max</span><span class="p">(</span><span class="n">before_lengths</span><span class="p">),</span>
					<span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">before_lengths</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">after_lengths</span><span class="p">))</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">before_lengths</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
							 <span class="p">)</span>
		<span class="c1"># sentence cut</span>
		<span class="k">return</span> <span class="n">sentences</span></div>

	<span class="k">if</span> <span class="n">is_build_private_docs</span><span class="p">():</span>
		<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;data (Any): the object returned by :meth:`_SentenceContent.get_data`&#39;&#39;&#39;</span>

	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="Sentence.trim_in_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Sentence.trim_in_ids">[docs]</a>	<span class="k">def</span> <span class="nf">trim_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Find the first special token indicating the sentence is over and remove all the tokens after it (included).</span>
<span class="sd">		Then remove all trailing ``pad``. {_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): The input ids.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

	<span class="k">def</span> <span class="nf">_remove_special_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">go_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">eos_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Try to remove special token (``go_id`` at the beginning and the ``eos_id`` at the end) in ``ids``.</span>
<span class="sd">		{_SENTENCE_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			ids (List[int]): the original ids</span>
<span class="sd">			go_id (int): go token</span>
<span class="sd">			eos_id (int): eos token</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">ids</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">ids</span>
		<span class="n">st</span><span class="p">,</span> <span class="n">ed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
		<span class="k">if</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">go_id</span><span class="p">:</span>
			<span class="n">st</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="n">ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">eos_id</span><span class="p">:</span>
			<span class="n">ed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="k">return</span> <span class="n">ids</span><span class="p">[</span><span class="n">st</span><span class="p">:</span><span class="n">ed</span><span class="p">]</span>

	<span class="c1"># copy some functions from vocab</span>
	<span class="n">_VOCAB_MORE_DOCSTRING</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;It calls the method with the identical name of the :class:`Vocab` instance, </span><span class="se">\</span>
<span class="s1">		from ``self.get_vocab()``.&#39;&#39;&#39;</span>
	<span class="n">frequent_vocab_size</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;frequent_vocab_size&quot;</span><span class="p">)</span>
	<span class="n">all_vocab_size</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;all_vocab_size&quot;</span><span class="p">)</span>
	<span class="n">frequent_vocab_list</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;frequent_vocab_list&quot;</span><span class="p">)</span>
	<span class="n">all_vocab_list</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;all_vocab_list&quot;</span><span class="p">)</span>
	<span class="n">get_special_tokens_mapping</span> <span class="o">=</span> <span class="n">copy_func</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;get_special_tokens_mapping&quot;</span><span class="p">)</span>
	<span class="n">get_special_tokens_id</span> <span class="o">=</span> <span class="n">copy_func</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;get_special_tokens_id&quot;</span><span class="p">)</span>
	<span class="n">pad_id</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;pad_id&quot;</span><span class="p">)</span>
	<span class="n">unk_id</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;unk_id&quot;</span><span class="p">)</span>
	<span class="n">go_id</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;go_id&quot;</span><span class="p">)</span>
	<span class="n">eos_id</span> <span class="o">=</span> <span class="n">copy_property</span><span class="p">(</span><span class="n">get_vocab</span><span class="p">,</span> <span class="n">Vocab</span><span class="p">,</span> <span class="s2">&quot;eos_id&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SentenceDefault"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceDefault">[docs]</a><span class="k">class</span> <span class="nc">SentenceDefault</span><span class="p">(</span><span class="n">Sentence</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Sentence`, :class:`.dataloader.Field`</span>

<span class="sd">	A common use field for sentence.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SENTENCE_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:GeneralVocab&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">,</span> \
				<span class="n">vocab</span><span class="o">=</span><span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="o">=</span><span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="o">=</span><span class="n">max_sent_length</span><span class="p">,</span> \
				<span class="n">convert_to_lower_letter</span><span class="o">=</span><span class="n">convert_to_lower_letter</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">Vocab</span>

	<span class="k">def</span> <span class="nf">add_special_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">go_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">ids</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">remove_special_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">trim</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">remove_special</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_special_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">go_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ids</span>

	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		The function will return a dict, containing:</span>

<span class="s2">		* ``FIELDNAME`` (``np.ndarray[batch_size, max_sent_length_in_batch]``):</span>
<span class="s2">		  Padded sentences in id formats. It only contains frequent vocabs, and rare words are replaced by ``unk_id``.</span>
<span class="s2">		* ``FIELDNAME_allvocabs`` (``np.ndarray[batch_size, max_sent_length_in_batch]``):</span>
<span class="s2">		  Padded sentences in id formats. It contains frequent vocabs and rare vocabs.</span>
<span class="s2">		* ``FIELDNAME_length`` (``np.ndarray[batch_size]``): The length of sentences.</span>
<span class="s2">		* ``FIELDNAME_str`` (``List[str]``): The raw sentences.</span>

<span class="s2">		where</span>

<span class="s2">		* ``FIELDNAME`` is the name of the field.</span>
<span class="s2">		* ``batch_size`` is ``len(indexes)``.</span>
<span class="s2">		* ``max_sent_length_in_batch`` is the maximum length of sentences in the batch.</span>
<span class="s2">	&quot;&quot;&quot;</span>
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		Examples:</span>
<span class="s2">			&gt;&gt;&gt; # 	all_vocab_list = [&quot;&lt;pad&gt;&quot;, &quot;&lt;unk&gt;&quot;, &quot;&lt;go&gt;&quot;, &quot;&lt;eos&gt;&quot;, &quot;Life&quot;, &quot;is&quot;, &quot;short&quot;, &quot;.&quot;,</span>
<span class="s2">			&gt;&gt;&gt; #		&quot;PHP&quot;, &quot;the&quot;, &quot;best&quot;, &quot;language&quot;, &quot;in&quot;, &quot;world&quot;]</span>
<span class="s2">			&gt;&gt;&gt; # 	frequent_vocab_size = 11</span>
<span class="s2">			&gt;&gt;&gt; #	frequent_vocab_list = [&quot;&lt;pad&gt;&quot;, &quot;&lt;unk&gt;&quot;, &quot;&lt;go&gt;&quot;, &quot;&lt;eos&gt;&quot;, &quot;Life&quot;, &quot;is&quot;, &quot;short&quot;, &quot;.&quot;,</span>
<span class="s2">			&gt;&gt;&gt; #		&quot;PHP&quot;, &quot;the&quot;, &quot;best&quot;]</span>
<span class="s2">			&gt;&gt;&gt; field.get_batch(&#39;sent&#39;, data, [0, 1])</span>
<span class="s2">			{</span>
<span class="s2">				&quot;sent&quot;: numpy.array([</span>
<span class="s2">					[2, 4, 5, 6, 7, 3, 0, 0, 0, 0, 0],	  # &lt;go&gt; Life is short . &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[2, 8, 5, 9, 10, 1, 1, 9, 1, 7, 3],	 # &lt;go&gt; PHP is the best &lt;unk&gt; &lt;unk&gt; the &lt;unk&gt; . &lt;eos&gt;</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_length&quot;: numpy.array([6, 11]), # length of sentences</span>
<span class="s2">				&quot;sent_allvocabs&quot;: numpy.array([</span>
<span class="s2">					[2, 4, 5, 6, 7, 3, 0, 0, 0, 0, 0],	  # &lt;go&gt; Life is short . &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[2, 8, 5, 9, 10, 11, 12, 9, 13, 7, 3],  # &lt;go&gt; PHP is the best language in the world . &lt;eos&gt;</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_str&quot;: [</span>
<span class="s2">					&quot;Life is short.&quot;,</span>
<span class="s2">					&quot;PHP is the best language in the world.&quot;,</span>
<span class="s2">				],</span>
<span class="s2">			}</span>
<span class="s2">	&quot;&quot;&quot;</span>
<div class="viewcode-block" id="SentenceDefault.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceDefault.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">GeneralVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Subclass must override get_batch if self.vocab is not a GeneralVocab.&quot;</span><span class="p">)</span>
		<span class="n">res</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res_sent</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">pad_id</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">sent</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">res_sent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sent</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_sent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res_sent</span><span class="p">[</span><span class="n">res_sent</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">frequent_vocab_size</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">unk_id</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div>

	<span class="k">def</span> <span class="nf">trim_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">trim_before_target</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ids</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">pad_id</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">ids</span></div>

<div class="viewcode-block" id="SentenceGPT2"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceGPT2">[docs]</a><span class="k">class</span> <span class="nc">SentenceGPT2</span><span class="p">(</span><span class="n">Sentence</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Sentence`, :class:`.dataloader.Field`</span>

<span class="sd">	A field for sentence in the format of GPT2.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SENTENCE_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:PretrainedVocab&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PretrainedVocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">,</span> \
				<span class="n">vocab</span><span class="o">=</span><span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="o">=</span><span class="n">vocab_from_mappings</span><span class="p">,</span>\
				<span class="n">max_sent_length</span><span class="o">=</span><span class="n">max_sent_length</span><span class="p">,</span> \
				<span class="n">convert_to_lower_letter</span><span class="o">=</span><span class="n">convert_to_lower_letter</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">get_tokenizer_class</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;GPT2Tokenizer&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a pretrained tokenizer compatible with gpt2&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">inner_tokenizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenizer</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">PretrainedVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a PretrainedVocab for SentenceGPT2 field&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">PretrainedVocab</span>

	<span class="k">def</span> <span class="nf">add_special_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">ids</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">remove_special_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">trim</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">remove_special</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_special_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ids</span>

	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">_GET_BATCH_RETURN_VALUE</span>

	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		Examples:</span>
<span class="s2">			&gt;&gt;&gt; # This example is based on GPT2Tokenizer. The vocab files are in ./tests/dummy_gpt2vocab.</span>
<span class="s2">			&gt;&gt;&gt; # field.eos_id = 413 # &lt;|endoftext|&gt;, also used for &lt;pad&gt;, &lt;unk&gt;, &lt;go&gt;</span>
<span class="s2">			&gt;&gt;&gt; field.get_batch(&#39;sent&#39;, data, [0, 2])</span>
<span class="s2">			{</span>
<span class="s2">				&quot;sent&quot;: numpy.array([</span>
<span class="s2">					[413, 6, 134, 321, 407, 107, 157, 121, 372, 201, 402, 105, 413, 413, 413, 413],</span>
<span class="s2">						# [&#39;&lt;|endoftext|&gt;&#39;, &#39;A&#39;, &#39;bicycle&#39;, &#39;replica&#39;, &#39;with&#39;, &#39;a&#39;, &#39;clock&#39;, &#39;as&#39;, &#39;the&#39;,</span>
<span class="s2">						#	&#39;front&#39;, &#39;wheel&#39;, &#39;.&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;]</span>
<span class="s2">					[413, 6, 149, 370, 330, 384, 126, 298, 236, 130, 107, 255, 298, 149, 105, 413],</span>
<span class="s2">						# [&#39;&lt;|endoftext|&gt;&#39;, &#39;A&#39;, &#39;car&#39;, &#39;that&#39;, &#39;seems&#39;, &#39;to&#39;, &#39;be&#39;, &#39;parked&#39;, &#39;illegally&#39;,</span>
<span class="s2">						#	&#39;behind&#39;, &#39;a&#39;, &#39;legally&#39;, &#39;parked&#39;, &#39;car&#39;, &#39;.&#39;, &#39;&lt;|endoftext|&gt;&#39;]</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_length&quot;: numpy.array([13, 16]), # length of sentences</span>
<span class="s2">				&quot;sent_allvocabs&quot;: numpy.array([</span>
<span class="s2">					[413, 6, 134, 321, 407, 107, 157, 121, 372, 201, 402, 105, 413, 413, 413, 413],</span>
<span class="s2">						# [&#39;&lt;|endoftext|&gt;&#39;, &#39;A&#39;, &#39;bicycle&#39;, &#39;replica&#39;, &#39;with&#39;, &#39;a&#39;, &#39;clock&#39;, &#39;as&#39;, &#39;the&#39;,</span>
<span class="s2">						#	&#39;front&#39;, &#39;wheel&#39;, &#39;.&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;, &#39;&lt;|endoftext|&gt;&#39;]</span>
<span class="s2">					[413, 6, 149, 370, 330, 384, 126, 298, 236, 130, 107, 255, 298, 149, 105, 413],</span>
<span class="s2">						# [&#39;&lt;|endoftext|&gt;&#39;, &#39;A&#39;, &#39;car&#39;, &#39;that&#39;, &#39;seems&#39;, &#39;to&#39;, &#39;be&#39;, &#39;parked&#39;, &#39;illegally&#39;,</span>
<span class="s2">						#	&#39;behind&#39;, &#39;a&#39;, &#39;legally&#39;, &#39;parked&#39;, &#39;car&#39;, &#39;.&#39;, &#39;&lt;|endoftext|&gt;&#39;]</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_str&quot;: [</span>
<span class="s2">					&quot;A bicycle replica with a clock as the front wheel .&quot;,</span>
<span class="s2">					&quot;A car that seems to be parked illegally behind a legally parked car .&quot;,</span>
<span class="s2">				],</span>
<span class="s2">			}</span>
<span class="s2">		&quot;&quot;&quot;</span>
<div class="viewcode-block" id="SentenceGPT2.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceGPT2.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">res</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res_sent</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span>
		<span class="c1">#res_attn = res[name + &quot;_attnmask&quot;] = np.zeros((batch_size, np.max(res[name + &quot;_length&quot;])), dtype=int)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">sent</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">res_sent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sent</span>
		<span class="c1">#	res_attn[i, :len(sent)] = 1</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_sent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div>

	<span class="k">def</span> <span class="nf">trim_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">trim_before_target</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="n">trim_before_target</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ids</span></div>

<div class="viewcode-block" id="SentenceBERT"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceBERT">[docs]</a><span class="k">class</span> <span class="nc">SentenceBERT</span><span class="p">(</span><span class="n">Sentence</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Sentence`, :class:`.dataloader.Field`</span>

<span class="sd">	A field for sentence in the format of BERT.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SENTENCE_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:PretrainedVocab&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PretrainedVocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> \
			<span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">,</span> \
				<span class="n">vocab</span><span class="o">=</span><span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="o">=</span><span class="n">vocab_from_mappings</span><span class="p">,</span>\
				<span class="n">max_sent_length</span><span class="o">=</span><span class="n">max_sent_length</span><span class="p">,</span> \
				<span class="n">convert_to_lower_letter</span><span class="o">=</span><span class="n">convert_to_lower_letter</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">get_tokenizer_class</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;BertTokenizer&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a pretrained tokenizer compatible with BERT&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">inner_tokenizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenizer</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">PretrainedVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a PretrainedVocab for SentenceBERT field&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">PretrainedVocab</span>

	<span class="k">def</span> <span class="nf">add_special_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get_special_tokens_id</span><span class="p">(</span><span class="s2">&quot;cls&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ids</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get_special_tokens_id</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">)]</span>

	<span class="k">def</span> <span class="nf">remove_special_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">trim</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">remove_special</span><span class="p">:</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_special_in_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get_special_tokens_id</span><span class="p">(</span><span class="s2">&quot;cls&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get_special_tokens_id</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ids</span>

	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">_GET_BATCH_RETURN_VALUE</span>

	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		Examples:</span>
<span class="s2">			&gt;&gt;&gt; # This example is based on BertTokenizer. The vocab files are in ./tests/dummy_bertvocab.</span>
<span class="s2">			&gt;&gt;&gt; field.get_batch(&#39;sent&#39;, data, [0, 1])</span>
<span class="s2">			{</span>
<span class="s2">				&quot;sent&quot;: numpy.array([</span>
<span class="s2">					[101, 147,  37,  29, 359, 102,   0,   0,   0,   0,   0,   0,   0],</span>
<span class="s2">						# [&#39;&lt;cls&gt;&#39;, &#39;How&#39;, &#39;are&#39;, &#39;you&#39;, &#39;?&#39;, &#39;&lt;sep&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;]</span>
<span class="s2">				[101, 375, 334, 379, 127, 341, 350,  29, 328,   9,  29, 359, 102]</span>
<span class="s2">						# [&#39;&lt;cls&gt;&#39;, &#39;i&#39;, &#39;&#39;&#39;, &#39;m&#39;, &#39;fine&#39;, &#39;.&#39;,  &#39;thank&#39;, &#39;you&#39;, &#39;!&#39;, &#39;and&#39;, &#39;you&#39;, &#39;?&#39;, &#39;&lt;sep&gt;&#39;]</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_length&quot;: numpy.array([6, 13]), # length of sentences,</span>
<span class="s2">				&quot;sent_allvocabs&quot;: numpy.array([</span>
<span class="s2">					[101, 147,  37,  29, 359, 102,   0,   0,   0,   0,   0,   0,   0],</span>
<span class="s2">						# [&#39;&lt;cls&gt;&#39;, &#39;how&#39;, &#39;are&#39;, &#39;you&#39;, &#39;?&#39;, &#39;&lt;sep&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;, &#39;&lt;pad&gt;&#39;]</span>
<span class="s2">				[101, 375, 334, 379, 127, 341, 350,  29, 328,   9,  29, 359, 102]</span>
<span class="s2">						# [&#39;&lt;cls&gt;&#39;, &#39;i&#39;, &#39;&#39;&#39;, &#39;m&#39;, &#39;fine&#39;, &#39;.&#39;,  &#39;thank&#39;, &#39;you&#39;, &#39;!&#39;, &#39;and&#39;, &#39;you&#39;, &#39;?&#39;, &#39;&lt;sep&gt;&#39;]</span>
<span class="s2">				]),</span>
<span class="s2">				&quot;sent_str&quot;: [</span>
<span class="s2">					&quot;How are you?&quot;,</span>
<span class="s2">					&quot;I&#39;m fine. Thank you! And you?&quot;</span>
<span class="s2">				],</span>
<span class="s2">			}</span>
<span class="s2">		&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SentenceBERT.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SentenceBERT.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">res</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res_sent</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_length&quot;</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">pad_id</span>
		<span class="c1">#res_attn = res[name + &quot;_attnmask&quot;] = np.zeros((batch_size, np.max(res[name + &quot;_length&quot;])), dtype=int)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">sent</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">res_sent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sent</span>
		<span class="c1">#	res_attn[i, :len(sent)] = 1</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_sent</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div>

	<span class="k">def</span> <span class="nf">trim_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
		<span class="c1"># The first token can&#39;t be the sep token</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">trim_before_target</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">get_special_tokens_id</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ids</span></div>


<span class="k">class</span> <span class="nc">_SessionContent</span><span class="p">(</span><span class="n">_FieldContent</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Store the content data of :class:`Session` Field.</span>
<span class="sd">		Different from :class:`Field`, it won&#39;t be shared between fields or dataloader,</span>
<span class="sd">		and it can save data.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="s2">&quot;Session&quot;</span><span class="p">,</span> <span class="n">vocab_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab_from</span> <span class="o">=</span> <span class="n">vocab_from</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_get_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
		<span class="sa">r</span><span class="sd">&quot;&quot;&quot;read **several(one or more)** elements and returns a 2-tuple (the next session, and the number of elements it reads).</span>
<span class="sd">		The first several non-space elements in `dataset`, followed by a &#39;\\n&#39;, are regarded as a session.</span>
<span class="sd">		The first element must not be empty string or &#39;\\n&#39;.</span>
<span class="sd">		Note that it may raise StopIteration.</span>

<span class="sd">		Arguments:</span>
<span class="sd">			{_FieldContent._GET_NEXT_ARG}</span>
<span class="sd">		Examples:</span>
<span class="sd">			&gt;&gt;&gt; dataset = iter([&quot;a\n&quot;, &quot;b\n&quot;, &quot;\n&quot;, &quot;c\n&quot;, &quot;d\e&quot;, &quot;e\n&quot;, &#39;\n&#39;])</span>
<span class="sd">			&gt;&gt;&gt; session_field = &quot;Session&quot;  # For simplicity, `session_field` is a string, rather than a Session object.</span>
<span class="sd">			&gt;&gt;&gt; field_content = _SessionContent(session_field, &quot;test&quot;)</span>
<span class="sd">			&gt;&gt;&gt; field_content._get_next(dataset)</span>
<span class="sd">			([&#39;a&#39;, &#39;b&#39;], 2)  # The first session. &#39;\n&#39; separates sessions.</span>
<span class="sd">			&gt;&gt;&gt; field_content._get_next(dataset)</span>
<span class="sd">			([&#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 3)  # The second(last) session. For the last session, it doesn&#39;t matter whether it&#39;s followed by &#39;\n&#39;.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">session</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
				<span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
					<span class="k">break</span>
				<span class="n">session</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
			<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">session</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">StopIteration</span>
		<span class="k">return</span> <span class="n">session</span><span class="p">,</span> <span class="n">lineno</span>

	<span class="k">def</span> <span class="nf">process_before_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">raw_data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">:</span>
			<span class="n">raw_data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span> <span class="o">=</span> <span class="n">raw_data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span> <span class="o">=</span> <span class="n">tokenized_sessions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">tokenize_sessions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">)</span>

		<span class="n">data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">tokenized_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span><span class="p">:</span>
			<span class="n">data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">tokenized_data</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span> <span class="o">=</span> <span class="n">data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">get_vocab</span><span class="p">()</span><span class="o">.</span><span class="n">add_tokens</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">tokenized_sessions</span><span class="p">))),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab_from</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
		<span class="n">id_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">process_sessions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_tokenized_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">id_data</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">}</span>

<div class="viewcode-block" id="Session"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session">[docs]</a><span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="n">Sentence</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`</span>

<span class="sd">	A field for session. Each session is a list of sentences.</span>

<span class="sd">	{Sentence.INIT_DOCSTRING}</span>

<span class="sd">			max_turn_length (int, _InfiniteLength, optional): Set the maximum turn length of a session.</span>
<span class="sd">				If it&#39;s an integer, any session, whose turn length is more than ``max_turn_length`` is shortened to</span>
<span class="sd">				first ``max_sent_length`` turns. The left turns are ignored.</span>
<span class="sd">				If it&#39;s ``None`` or ``Sentence.INFINITE_LENGTH``, sessions won&#39;t be shortened and all turns are remained.</span>
<span class="sd">				Default: ``None``.</span>

<span class="sd">	{SESSION_INPUT_FORMAT}</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">SESSION_INPUT_FORMAT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	Input Format</span>
<span class="s2">		This field read multiple line of sentences per sample, until a blank line.</span>
<span class="s2">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_turn_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">Session</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
				<span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is an abstract class. Please use </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Session</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">SessionDefault</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">)</span>
		<span class="k">with</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">max_turn_length</span><span class="o">=</span><span class="n">max_turn_length</span><span class="p">):</span>
			<span class="n">max_turn_length</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_turn_length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">max_turn_length</span> <span class="o">==</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INFINITE_LENGTH</span><span class="p">:</span>
				<span class="n">max_turn_length</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># max_turn_length is used for slice. So, None means that turn_length is unlimited.</span>
		<span class="k">if</span> <span class="n">max_turn_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max_turn_length must be None or a positive integer&quot;</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_turn_length</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">max_turn_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">max_turn_length</span> <span class="o">=</span> <span class="n">max_turn_length</span>
	
	<span class="n">_SESSION_MORE_DOCSTRING</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<div class="viewcode-block" id="Session.tokenize_sessions"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session.tokenize_sessions">[docs]</a>	<span class="k">def</span> <span class="nf">tokenize_sessions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sessions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RawSessionType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TokenizedSessionType</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;Tokenize ``sessions``.</span>

<span class="sd">		{_SESSION_MORE_DOCSTRING}</span>
<span class="sd">		</span>
<span class="sd">		* Convert the tokens to lower case if ``self.convert_to_lower_letter`` is ``True``.</span>
<span class="sd">		</span>

<span class="sd">		Arguments:</span>
<span class="sd">			sessions (List[List[str]]): The list of sessions to be tokenized.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenize_sentences</span><span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="n">sessions</span><span class="p">]</span></div>

	<span class="n">PROCESS_ARG</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">PROCESS_ARG</span>
<div class="viewcode-block" id="Session.process_sessions"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session.process_sessions">[docs]</a>	<span class="k">def</span> <span class="nf">process_sessions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sessions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TokenizedSessionType</span><span class="p">],</span> <span class="n">add_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
						 <span class="n">only_frequent_word</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Process input sessions.</span>

<span class="sd">		{_SESSION_MORE_DOCSTRING}</span>

<span class="sd">		* If ``self.max_turn_length`` is not ``None`` and ``cut`` is ``True``,</span>
<span class="sd">		  sessions, whose length are more than ``self.max_turn_length``, are</span>
<span class="sd">		  shorten to first ``self.max_turn_length`` sentences.</span>
<span class="sd">		* If sessions havent been tokenized, tokenize them by invoking :meth:`self.tokenize_sessions`</span>
<span class="sd">		* Then, convert the list of tokens to a list of ids.</span>
<span class="sd">		* If ``self.max_sent_length`` is not ``None`` and ``cut`` is ``True``,</span>
<span class="sd">		  sentences, whose length are more than ``self.max_sent_length``, are</span>
<span class="sd">		  shorten to first ``self.max_sent_length`` tokens.</span>
<span class="sd">		</span>
<span class="sd">		</span>
<span class="sd">		</span>
<span class="sd">		Arguments:</span>
<span class="sd">			sessions (List[List[str], List[List[str]]]):</span>
<span class="sd">				sentences in a session can be a str or a list of tokens.</span>
<span class="sd">			{PROCESS_ARG}</span>
<span class="sd">			cut (bool, optional): Whether to cut sessions/sentences with too many sentences/tokens. Default: ``True``.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># Cut sessions.</span>
		<span class="c1"># If a session&#39;s turn length &gt; `self.max_turn_length`, retain the first `self.max_turn_length` sentences and discard the rest.</span>
		<span class="k">if</span> <span class="n">cut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_turn_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">turn_length_before_cut</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">sessions</span><span class="p">))</span>
			<span class="n">max_turn_length_before_cut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">turn_length_before_cut</span><span class="p">)</span>
			<span class="n">sessions</span> <span class="o">=</span> <span class="p">[</span><span class="n">session</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_turn_length</span><span class="p">]</span> <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="n">sessions</span><span class="p">]</span>
			<span class="n">turn_length_after_cut</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">sessions</span><span class="p">))</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sessions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;max turn length before cut: </span><span class="si">%d</span><span class="s2">, cut percent: </span><span class="si">%.2f%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="n">max_turn_length_before_cut</span><span class="p">,</span>
					<span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">turn_length_after_cut</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">turn_length_before_cut</span><span class="p">)))</span>
							 <span class="p">)</span>

		<span class="n">sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TokenizedSentenceType</span><span class="p">]</span>
		<span class="n">session_length</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
		<span class="n">sentences</span><span class="p">,</span> <span class="n">session_lengths</span> <span class="o">=</span> <span class="n">chain_sessions</span><span class="p">(</span><span class="n">sessions</span><span class="p">)</span>
		<span class="n">processed_sessions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_sentences</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="n">add_special</span><span class="o">=</span><span class="n">add_special</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="n">only_frequent_word</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">)</span>
		<span class="n">processed_sessions</span> <span class="o">=</span> <span class="n">restore_sessions</span><span class="p">(</span><span class="n">processed_sessions</span><span class="p">,</span> <span class="n">session_lengths</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">processed_sessions</span></div>

	<span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SessionContent</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_SessionContent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab_from_mappings</span><span class="p">[</span><span class="n">set_name</span><span class="p">])</span>
		<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Unknown set_name </span><span class="si">%s</span><span class="s2">, do not specify in the vocab_from_mappings&quot;</span> <span class="o">%</span> <span class="n">set_name</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

<div class="viewcode-block" id="Session.convert_multi_turn_tokens_to_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session.convert_multi_turn_tokens_to_ids">[docs]</a>	<span class="k">def</span> <span class="nf">convert_multi_turn_tokens_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">add_special</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> \
	<span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
		<span class="sd">&#39;&#39;&#39;Convert list of tokenized sentences to list of sentence ids. {_SESSION_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			session (List[List[str]]): The tokenized sentences to be converted.{CONVERT_TO_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">add_special</span><span class="p">,</span> <span class="n">only_frequent_word</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">session</span><span class="p">]</span></div>

<div class="viewcode-block" id="Session.convert_multi_turn_ids_to_tokens"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session.convert_multi_turn_ids_to_tokens">[docs]</a>	<span class="k">def</span> <span class="nf">convert_multi_turn_ids_to_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session_ids</span><span class="p">,</span> <span class="n">remove_special</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Convert list of sentence ids to list of sentences. {_SESSION_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			session_ids (List[List[int]]): The sentence ids to be converted.{CONVERT_FROM_ID_ARG}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_ids_to_tokens</span><span class="p">(</span><span class="n">sent_ids</span><span class="p">,</span> <span class="n">remove_special</span><span class="p">,</span> <span class="n">trim</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent_ids</span> <span class="ow">in</span> <span class="n">session_ids</span><span class="p">]</span></div>

<div class="viewcode-block" id="Session.multi_turn_trim_in_ids"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.Session.multi_turn_trim_in_ids">[docs]</a>	<span class="k">def</span> <span class="nf">multi_turn_trim_in_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
		<span class="sd">&#39;&#39;&#39;For each sentence ids in session,</span>
<span class="sd">		find the first special token indicating the sentence is over and remove all the tokens after it (included).</span>
<span class="sd">		Then remove all trailing ``pad``. {_SESSION_MORE_DOCSTRING}</span>

<span class="sd">		Arguments:</span>
<span class="sd">			session_ids (List[List[int]]): The input ids of session.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">trim_in_ids</span><span class="p">(</span><span class="n">sent_ids</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent_ids</span> <span class="ow">in</span> <span class="n">session_ids</span><span class="p">]</span></div>

	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">get_pretrained_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pretrained</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">{</span>
			<span class="s2">&quot;gpt2&quot;</span><span class="p">:</span> <span class="n">SessionGPT2</span><span class="p">,</span>
			<span class="s2">&quot;bert&quot;</span><span class="p">:</span> <span class="n">SessionBERT</span>
		<span class="p">}[</span><span class="n">pretrained</span><span class="p">]</span>

	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">get_candidate_pretrained_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pretrained</span><span class="p">):</span>
		<span class="k">return</span> <span class="p">{</span>
			<span class="s2">&quot;gpt2&quot;</span><span class="p">:</span> <span class="n">SentenceCandidateGPT2</span><span class="p">,</span>
			<span class="s2">&quot;bert&quot;</span><span class="p">:</span> <span class="n">SentenceCandidateBERT</span>
		<span class="p">}[</span><span class="n">pretrained</span><span class="p">]</span></div>


<div class="viewcode-block" id="SessionDefault"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionDefault">[docs]</a><span class="k">class</span> <span class="nc">SessionDefault</span><span class="p">(</span><span class="n">Session</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Session`, :class:`.dataloader.Field`</span>

<span class="sd">	A common use field for sessions.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SESSION_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:GeneralVocab&quot;</span><span class="p">)</span>

	<span class="n">add_special_to_ids</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">add_special_to_ids</span>
	<span class="n">remove_special_in_ids</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">remove_special_in_ids</span>
	<span class="n">trim_in_ids</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">trim_in_ids</span>

	<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="n">SentenceDefault</span><span class="o">.</span><span class="n">_GET_BATCH_DATA_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_SentenceContent</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">_SessionContent</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;sentences&#39;</span><span class="p">,</span> <span class="s1">&#39;sessions&#39;</span><span class="p">)</span>
	
	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		The function will return a dict, containing:</span>

<span class="s2">		* ``FIELDNAME`` (``np.ndarray[batch_size, max_turn_length_in_batch, max_sent_length_in_batch]``):</span>
<span class="s2">		  Padded sessions in id formats. It only contains frequent vocabs, and rare words are replaced by ``unk_id``.</span>
<span class="s2">		* ``FIELDNAME_allvocabs`` (``np.ndarray[batch_size, max_turn_length_in_batch, max_sent_length_in_batch]``):</span>
<span class="s2">		  Padded sessions in id formats. It contains frequent vocabs and rare vocabs.</span>
<span class="s2">		* ``FIELDNAME_turn_length`` (``np.ndarray[batch_size]``): The turn numbers of sessions.</span>
<span class="s2">		* ``FIELDNAME_sent_length`` (``List[List[int]]``): The length of sentences of sessions.</span>
<span class="s2">		* ``FIELDNAME_str`` (``List[str]``): The raw sessions.</span>

<span class="s2">		where</span>

<span class="s2">		* ``FIELDNAME`` is the name of the field.</span>
<span class="s2">		* ``batch_size`` is ``len(indexes)``.</span>
<span class="s2">		* ``max_turn_length_in_batch`` is the maximum turn number of sessions in the batch.</span>
<span class="s2">		* ``max_sent_length_in_batch`` is the maximum length of sentences in the batch.</span>
<span class="s2">	&quot;&quot;&quot;</span>
	
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	Examples:</span>
<span class="s2">		&gt;&gt;&gt; # 	dataset = iter([&#39;How are you?\n&#39;, &quot;I&#39;m fine. And you?\n&quot;, &quot;I&#39;m fine, too.\n&quot;, &quot;\n&quot;,</span>
<span class="s2">		&gt;&gt;&gt; # 		&quot;How to install cotk?\n&quot;, &quot;pip install cotk.\n&quot;, &quot;\n&quot;])</span>
<span class="s2">		&gt;&gt;&gt; # 	min_frequent_vocab_times = 2</span>
<span class="s2">		&gt;&gt;&gt; #	all_vocab_list = [&#39;&lt;pad&gt;&#39;, &#39;&lt;unk&gt;&#39;, &#39;&lt;go&gt;&#39;, &#39;&lt;eos&gt;&#39;, &#39;.&#39;, &#39;?&#39;, &quot;&#39;&quot;, &#39;How&#39;, &#39;I&#39;,</span>
<span class="s2">		&gt;&gt;&gt; # 		&#39;cotk&#39;, &#39;fine&#39;, &#39;install&#39;, &#39;m&#39;, &#39;you&#39;, &#39;,&#39;, &#39;And&#39;, &#39;are&#39;, &#39;pip&#39;, &#39;to&#39;, &#39;too&#39;]</span>
<span class="s2">		&gt;&gt;&gt; #	frequent_vocab_size = 14</span>
<span class="s2">		&gt;&gt;&gt; # 	frequent_vocab_list = [&#39;&lt;pad&gt;&#39;, &#39;&lt;unk&gt;&#39;, &#39;&lt;go&gt;&#39;, &#39;&lt;eos&gt;&#39;, &#39;.&#39;, &#39;?&#39;, &quot;&#39;&quot;, &#39;How&#39;, &#39;I&#39;,</span>
<span class="s2">		&gt;&gt;&gt; # 		&#39;cotk&#39;, &#39;fine&#39;, &#39;install&#39;, &#39;m&#39;, &#39;you&#39;]</span>
<span class="s2">		&gt;&gt;&gt; # 	data = {</span>
<span class="s2">		&gt;&gt;&gt; # 		&#39;id&#39;: [</span>
<span class="s2">		&gt;&gt;&gt; #			[</span>
<span class="s2">		&gt;&gt;&gt; #				[2, 7, 16, 13, 5, 3],</span>
<span class="s2">		&gt;&gt;&gt; #				[2, 8, 6, 12, 10, 4, 15, 13, 5, 3],</span>
<span class="s2">		&gt;&gt;&gt; #				[2, 8, 6, 12, 10, 14, 19, 4, 3],</span>
<span class="s2">		&gt;&gt;&gt; #			],</span>
<span class="s2">		&gt;&gt;&gt; #			[</span>
<span class="s2">		&gt;&gt;&gt; #				[2, 7, 18, 11, 9, 5, 3],</span>
<span class="s2">		&gt;&gt;&gt; #				[2, 17, 11, 9, 4, 3],</span>
<span class="s2">		&gt;&gt;&gt; #			]</span>
<span class="s2">		&gt;&gt;&gt; #		],</span>
<span class="s2">		&gt;&gt;&gt; #		&#39;str&#39;: [</span>
<span class="s2">		&gt;&gt;&gt; #			[</span>
<span class="s2">		&gt;&gt;&gt; # 				&#39;How are you?&#39;,</span>
<span class="s2">		&gt;&gt;&gt; #				&quot;I&#39;m fine. And you?&quot;,</span>
<span class="s2">		&gt;&gt;&gt; #				&quot;I&#39;m fine, too.&quot;</span>
<span class="s2">		&gt;&gt;&gt; #			],</span>
<span class="s2">		&gt;&gt;&gt; #			[</span>
<span class="s2">		&gt;&gt;&gt; #				&#39;How to install cotk?&#39;,</span>
<span class="s2">		&gt;&gt;&gt; #				&#39;pip install cotk.&#39;</span>
<span class="s2">		&gt;&gt;&gt; #			]</span>
<span class="s2">		&gt;&gt;&gt; #</span>
<span class="s2">		&gt;&gt;&gt; #	}</span>
<span class="s2">		&gt;&gt;&gt; field.get_batch(&#39;session&#39;, data, [0, 1])</span>
<span class="s2">		{</span>
<span class="s2">			&#39;session_turn_length&#39;: numpy.array([3, 2]),</span>
<span class="s2">			&#39;session_sent_length&#39;: [</span>
<span class="s2">				[6, 10, 9],</span>
<span class="s2">				[7, 6]</span>
<span class="s2">			],</span>
<span class="s2">			&#39;session&#39;: numpy.array([</span>
<span class="s2">				[</span>
<span class="s2">					[ 2,  7,  1, 13,  5,  3,  0,  0,  0,  0], # &lt;go&gt; How &lt;unk&gt; you? &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 2,  8,  6, 12, 10,  4,  1, 13,  5,  3], # &lt;go&gt; I&#39;m fine. &lt;unk&gt; you? &lt;eos&gt;</span>
<span class="s2">					[ 2,  8,  6, 12, 10,  1,  1,  4,  3,  0]  # &lt;go&gt; I&#39;m fine &lt;unk&gt; &lt;unk&gt;. &lt;eos&gt; &lt;pad&gt;</span>
<span class="s2">				],</span>
<span class="s2">				[</span>
<span class="s2">					[ 2,  7,  1, 11,  9,  5,  3,  0,  0,  0], # &lt;go&gt; How &lt;unk&gt; install cotk? &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 2,  1, 11,  9,  4,  3,  0,  0,  0,  0], # &lt;go&gt; &lt;unk&gt; install cotk. &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0]  # all &lt;pad&gt;</span>
<span class="s2">				]</span>
<span class="s2">			]),</span>
<span class="s2">			&#39;session_allvocabs&#39;: numpy.array([</span>
<span class="s2">				[</span>
<span class="s2">					[ 2,  7, 16, 13,  5,  3,  0,  0,  0,  0], # &lt;go&gt; How are you? &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 2,  8,  6, 12, 10,  4, 15, 13,  5,  3], # &lt;go&gt; I&#39;m fine. And you? &lt;eos&gt;</span>
<span class="s2">					[ 2,  8,  6, 12, 10, 14, 19,  4,  3,  0]  # &lt;go&gt; I&#39;m fine, too. &lt;eos&gt; &lt;pad&gt;</span>
<span class="s2">				],</span>
<span class="s2">				[</span>
<span class="s2">					[ 2,  7, 18, 11,  9,  5,  3,  0,  0,  0], # &lt;go&gt; How to install cotk? &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 2, 17, 11,  9,  4,  3,  0,  0,  0,  0], # &lt;go&gt; pip install cotk. &lt;eos&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt; &lt;pad&gt;</span>
<span class="s2">					[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0]  # all &lt;pad&gt;</span>
<span class="s2">				]</span>
<span class="s2">			]),</span>
<span class="s2">			&#39;session_str&#39;: [</span>
<span class="s2">				[</span>
<span class="s2">					&#39;How are you?&#39;,</span>
<span class="s2">					&quot;I&#39;m fine. And you?&quot;,</span>
<span class="s2">					&quot;I&#39;m fine, too.&quot;</span>
<span class="s2">				],</span>
<span class="s2">				[</span>
<span class="s2">					&#39;How to install cotk?&#39;,</span>
<span class="s2">					&#39;pip install cotk.&#39;</span>
<span class="s2">				]</span>
<span class="s2">			]</span>
<span class="s2">		}</span>
<span class="s2">	&quot;&quot;&quot;</span>
<div class="viewcode-block" id="SessionDefault.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionDefault.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">GeneralVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Subclass must override get_batch if self.vocab is not a GeneralVocab.&quot;</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">turn_lengths</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_turn_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="n">max_sent_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]))</span>
		<span class="n">res_session</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">turn_lengths</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_sent_length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_sent_length</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">))</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">session</span><span class="p">]</span>
			<span class="n">res_session</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">session</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_session</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res_session</span><span class="p">[</span><span class="n">res_session</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">frequent_vocab_size</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">unk_id</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="SessionGPT2"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionGPT2">[docs]</a><span class="k">class</span> <span class="nc">SessionGPT2</span><span class="p">(</span><span class="n">Session</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Session`, :class:`.dataloader.Field`</span>

<span class="sd">	A field for session in the format of GPT2.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SESSION_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:PretrainedVocab&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PretrainedVocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_turn_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">,</span> <span class="n">max_turn_length</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">get_tokenizer_class</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;GPT2Tokenizer&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a pretrained tokenizer compatible with gpt2&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">inner_tokenizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenizer</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">PretrainedVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a PretrainedVocab for SentenceGPT2 field&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">PretrainedVocab</span>

	<span class="n">add_special_to_ids</span> <span class="o">=</span> <span class="n">SentenceGPT2</span><span class="o">.</span><span class="n">add_special_to_ids</span>
	<span class="n">remove_special_in_ids</span> <span class="o">=</span> <span class="n">SentenceGPT2</span><span class="o">.</span><span class="n">remove_special_in_ids</span>
	<span class="n">trim_in_ids</span> <span class="o">=</span> <span class="n">SentenceGPT2</span><span class="o">.</span><span class="n">trim_in_ids</span>

	<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="n">SessionDefault</span><span class="o">.</span><span class="n">_GET_BATCH_DATA_DOCSTRING</span>
	<span class="c1"># TODO: update return value of get_batch. I have trouble with `GPT2Tokenizer.from_pretrained(&#39;gpt2&#39;)`</span>
	<span class="c1"># the following codes in Examples haven&#39;t been run.</span>
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	# NOTE: We only show the structure of return value of get_batch. The real value of each entry may depends on the loaded vocab.</span>
<span class="s2">	Examples:</span>
<span class="s2">		&gt;&gt;&gt; from transformers.tokenization_gpt2 import GPT2Tokenizer</span>
<span class="s2">		&gt;&gt;&gt; from cotk.dataloader.tokenizer import PretrainedTokenizer</span>
<span class="s2">		&gt;&gt;&gt; tokenizer = GPT2Tokenizer.from_pretrained(&#39;gpt2&#39;)</span>
<span class="s2">		&gt;&gt;&gt; field = SessionGPT2(PretrainedTokenizer(tokenizer))</span>
<span class="s2">		&gt;&gt;&gt; field_content = field._create(&#39;train&#39;)</span>
<span class="s2">		&gt;&gt;&gt; dataset = iter([&#39;How are you?\n&#39;, &quot;I&#39;m fine. Thank you! And you?\n&quot;, &quot;I&#39;m fine, too.\n&quot;, &quot;\n&quot;, &quot;How to install CoTk?\n&quot;, &quot;pip install cotk.\n&quot;, &quot;\n&quot;])</span>
<span class="s2">		&gt;&gt;&gt; while True:</span>
<span class="s2">		... 	try:</span>
<span class="s2">		... 		field_content.read_next(dataset)</span>
<span class="s2">		... 	except StopIteration:</span>
<span class="s2">		... 		break</span>
<span class="s2">		&gt;&gt;&gt; field_content.process_before_vocab()</span>
<span class="s2">		&gt;&gt;&gt; field.vocab.build_vocab()</span>
<span class="s2">		&gt;&gt;&gt; data = field_content.get_data()</span>
<span class="s2">		&gt;&gt;&gt; data</span>
<span class="s2">		{&#39;id&#39;: [[[2, 8, 18, 6, 5, 3],</span>
<span class="s2">				[2, 9, 7, 12, 10, 4, 17, 6, 13, 15, 6, 5, 3],</span>
<span class="s2">				[2, 9, 7, 12, 10, 14, 22, 4, 3]],</span>
<span class="s2">			   [[2, 8, 21, 11, 16, 5, 3], [2, 20, 11, 19, 4, 3]]],</span>
<span class="s2">		  &#39;str&#39;: [[&#39;How are you?&#39;, &quot;I&#39;m fine. Thank you! And you?&quot;, &quot;I&#39;m fine, too.&quot;],</span>
<span class="s2">			  [&#39;How to install CoTk?&#39;, &#39;pip install cotk.&#39;]]}</span>
<span class="s2">		&gt;&gt;&gt; batch_data = field.get_batch(&#39;session&#39;, data, [1])</span>
<span class="s2">		&gt;&gt;&gt; batch_data</span>
<span class="s2">		{&#39;session_turn_length&#39;: array([2]),</span>
<span class="s2">		  &#39;session_sent_length&#39;: [[7, 6]],</span>
<span class="s2">		  &#39;session&#39;: array([[[ 2,  8, 21, 11, 16,  5,  3],</span>
<span class="s2">						 [ 2, 20, 11, 19,  4,  3,  0]]]),</span>
<span class="s2">		  &#39;session_allvocabs&#39;: array([[[ 2,  8, 21, 11, 16,  5,  3],</span>
<span class="s2">						 [ 2, 20, 11, 19,  4,  3,  0]]]),</span>
<span class="s2">		  &#39;session_str&#39;: [[&#39;How to install CoTk?&#39;, &#39;pip install cotk.&#39;]]}</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_turn_length&#39; (`name` + &#39;_turn_length&#39;) is a :class:`np.ndarray` object with shape == (batch size, ). Each element is the length of corresponding sssion.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_sent_length&#39; (`name` + &#39;_sent_length&#39;) is List[List[int]]. Each integer is the length of corresponding sentence.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session&#39; (`name`) is a :class:`np.ndarray` object with shape == (batch size, max turn length, max sentence length).</span>
<span class="s2">		&gt;&gt;&gt;				# batch_data[&#39;session&#39;][i, j] is a sentence. batch_data[&#39;session&#39;][i, j, k] is an id.</span>
<span class="s2">		&gt;&gt;&gt;				# If `self.max_turn_length` is not None and j &gt;= `self.max_turn_length` or `self.max_sent_length` is not None and k &gt;= `self.max_sent_length`,</span>
<span class="s2">		&gt;&gt;&gt;				# batch_data[&#39;session&#39;][i, j, k] is `self.eos_id`.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_allvocabs&#39; (`name` + &#39;_allvocabs&#39;) is the same with &#39;session&#39;.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SessionGPT2.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionGPT2.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">turn_lengths</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_turn_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="n">max_sent_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]))</span>
		<span class="n">res_session</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">turn_lengths</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_sent_length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">eos_id</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_sent_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">))</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">session</span><span class="p">]</span>
			<span class="n">res_session</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">session</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_session</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="SessionBERT"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionBERT">[docs]</a><span class="k">class</span> <span class="nc">SessionBERT</span><span class="p">(</span><span class="n">Session</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Bases: :class:`.dataloader.Session`, :class:`.dataloader.Field`</span>

<span class="sd">	A field for session in the format of BERT.</span>

<span class="sd">	{INIT_DOCSTRING}</span>

<span class="sd">	{SESSION_INPUT_FORMAT}</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">INIT_DOCSTRING</span> <span class="o">=</span> <span class="n">Sentence</span><span class="o">.</span><span class="n">INIT_DOCSTRING</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:class:Vocab&quot;</span><span class="p">,</span> <span class="s2">&quot;:class:PretrainedVocab&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PretrainedVocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_turn_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">,</span> <span class="n">max_turn_length</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">PretrainedTokenizer</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">get_tokenizer_class</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;BertTokenizer&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a pretrained tokenizer compatible with bert&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">inner_tokenizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenizer</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">PretrainedVocab</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify a PretrainedVocab for SentenceBERT field&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span> <span class="n">PretrainedVocab</span>

	<span class="n">add_special_to_ids</span> <span class="o">=</span> <span class="n">SentenceBERT</span><span class="o">.</span><span class="n">add_special_to_ids</span>
	<span class="n">remove_special_in_ids</span> <span class="o">=</span> <span class="n">SentenceBERT</span><span class="o">.</span><span class="n">remove_special_in_ids</span>
	<span class="n">trim_in_ids</span> <span class="o">=</span> <span class="n">SentenceBERT</span><span class="o">.</span><span class="n">trim_in_ids</span>

	<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="n">SessionDefault</span><span class="o">.</span><span class="n">_GET_BATCH_DATA_DOCSTRING</span>
	<span class="c1"># TODO: update return value of get_batch. I have trouble with `BertTokenizer.from_pretrained(&#39;bert&#39;)`</span>
	<span class="c1"># the following codes in Examples haven&#39;t been run.</span>
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	# NOTE: We only show the structure of return value of get_batch. The real value of each entry may depends on the loaded vocab.</span>
<span class="s2">	Examples:</span>
<span class="s2">		&gt;&gt;&gt; from transformers.tokenization_bert import BertTokenizer</span>
<span class="s2">		&gt;&gt;&gt; from cotk.dataloader.tokenizer import PretrainedTokenizer</span>
<span class="s2">		&gt;&gt;&gt; tokenizer = BertTokenizer.from_pretrained(&#39;bert&#39;)</span>
<span class="s2">		&gt;&gt;&gt; field = SessionBERT(PretrainedTokenizer(tokenizer))</span>
<span class="s2">		&gt;&gt;&gt; field_content = field._create(&#39;train&#39;)</span>
<span class="s2">		&gt;&gt;&gt; dataset = iter([&#39;How are you?\n&#39;, &quot;I&#39;m fine. Thank you! And you?\n&quot;, &quot;I&#39;m fine, too.\n&quot;, &quot;\n&quot;, &quot;How to install CoTk?\n&quot;, &quot;pip install cotk.\n&quot;, &quot;\n&quot;])</span>
<span class="s2">		&gt;&gt;&gt; while True:</span>
<span class="s2">		... 	try:</span>
<span class="s2">		... 		field_content.read_next(dataset)</span>
<span class="s2">		... 	except StopIteration:</span>
<span class="s2">		... 		break</span>
<span class="s2">		&gt;&gt;&gt; field_content.process_before_vocab()</span>
<span class="s2">		&gt;&gt;&gt; field.vocab.build_vocab()</span>
<span class="s2">		&gt;&gt;&gt; data = field_content.get_data()</span>
<span class="s2">		&gt;&gt;&gt; data</span>
<span class="s2">		{&#39;id&#39;: [[[2, 8, 18, 6, 5, 3],</span>
<span class="s2">				[2, 9, 7, 12, 10, 4, 17, 6, 13, 15, 6, 5, 3],</span>
<span class="s2">				[2, 9, 7, 12, 10, 14, 22, 4, 3]],</span>
<span class="s2">			   [[2, 8, 21, 11, 16, 5, 3], [2, 20, 11, 19, 4, 3]]],</span>
<span class="s2">		  &#39;str&#39;: [[&#39;How are you?&#39;, &quot;I&#39;m fine. Thank you! And you?&quot;, &quot;I&#39;m fine, too.&quot;],</span>
<span class="s2">			  [&#39;How to install CoTk?&#39;, &#39;pip install cotk.&#39;]]}</span>
<span class="s2">		&gt;&gt;&gt; batch_data = field.get_batch(&#39;session&#39;, data, [1])</span>
<span class="s2">		&gt;&gt;&gt; batch_data</span>
<span class="s2">		{&#39;session_turn_length&#39;: array([2]),</span>
<span class="s2">		  &#39;session_sent_length&#39;: [[7, 6]],</span>
<span class="s2">		  &#39;session&#39;: array([[[ 2,  8, 21, 11, 16,  5,  3],</span>
<span class="s2">						 [ 2, 20, 11, 19,  4,  3,  0]]]),</span>
<span class="s2">		  &#39;session_allvocabs&#39;: array([[[ 2,  8, 21, 11, 16,  5,  3],</span>
<span class="s2">						 [ 2, 20, 11, 19,  4,  3,  0]]]),</span>
<span class="s2">		  &#39;session_str&#39;: [[&#39;How to install CoTk?&#39;, &#39;pip install cotk.&#39;]]}</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_turn_length&#39; (`name` + &#39;_turn_length&#39;) is a :class:`np.ndarray` object with shape == (batch size, ). Each element is the length of corresponding sssion.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_sent_length&#39; (`name` + &#39;_sent_length&#39;) is List[List[int]]. Each integer is the length of corresponding sentence.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session&#39; (`name`) is a :class:`np.ndarray` object with shape == (batch size, max turn length, max sentence length).</span>
<span class="s2">		&gt;&gt;&gt;				# batch_data[&#39;session&#39;][i, j] is a sentence. batch_data[&#39;session&#39;][i, j, k] is an id.</span>
<span class="s2">		&gt;&gt;&gt;				# If `self.max_turn_length` is not None and j &gt;= `self.max_turn_length` or `self.max_sent_length` is not None and k &gt;= `self.max_sent_length`,</span>
<span class="s2">		&gt;&gt;&gt;				# batch_data[&#39;session&#39;][i, j, k] is `self.pad_id`.</span>
<span class="s2">		&gt;&gt;&gt; # &#39;session_allvocabs&#39; (`name` + &#39;_allvocabs&#39;) is the same with &#39;session&#39;.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SessionBERT.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SessionBERT.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">data_id</span><span class="p">,</span> <span class="n">data_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">]</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
		<span class="n">turn_lengths</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_turn_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data_id</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="n">max_sent_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_sent_length&quot;</span><span class="p">]))</span>
		<span class="n">res_session</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">turn_lengths</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_sent_length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">pad_id</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">data_id</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">pad_id</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_sent_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">))</span> <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">session</span><span class="p">]</span>
			<span class="n">res_session</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">session</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_allvocabs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_session</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">res</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_str&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">res</span></div></div>


<span class="k">class</span> <span class="nc">SentenceCandidateDefault</span><span class="p">(</span><span class="n">SessionDefault</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`.</span>
<span class="sd">	A Field for candidate. Several sentences represent candidate answers of a dialog task.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">,</span>
						 <span class="n">max_turn_length</span><span class="o">=</span><span class="n">Sentence</span><span class="o">.</span><span class="n">INFINITE_LENGTH</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SentenceCandidateGPT2</span><span class="p">(</span><span class="n">SessionGPT2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`.</span>
<span class="sd">	A Field for candidate. Several sentences represent candidate answers of a dialog task. These sentences are in the format of GPT2.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">,</span>
						 <span class="n">max_turn_length</span><span class="o">=</span><span class="n">Sentence</span><span class="o">.</span><span class="n">INFINITE_LENGTH</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SentenceCandidateBERT</span><span class="p">(</span><span class="n">SessionBERT</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`.</span>
<span class="sd">	A Field for candidate. Several sentences represent candidate answers of a dialog task. These sentences are in the format of BERT.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">vocab_from_mappings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">max_sent_length</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_InfiniteLength</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
				 <span class="n">convert_to_lower_letter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab_from_mappings</span><span class="p">,</span> <span class="n">max_sent_length</span><span class="p">,</span> <span class="n">convert_to_lower_letter</span><span class="p">,</span>
						 <span class="n">max_turn_length</span><span class="o">=</span><span class="n">Sentence</span><span class="o">.</span><span class="n">INFINITE_LENGTH</span><span class="p">)</span>


<div class="viewcode-block" id="DenseLabel"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.DenseLabel">[docs]</a><span class="k">class</span> <span class="nc">DenseLabel</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`</span>

<span class="sd">	A field of categorical labels whose values are integer which</span>
<span class="sd">	ranges from ``0`` to ``label_types - 1``.</span>

<span class="sd">	See :class:`.dataloader.SparseLabel` for labels in ``str`` or sparse integer.</span>

<span class="sd">	Arguments:</span>

<span class="sd">		This class do not contains arguments for initialization.</span>

<span class="sd">	Input Format</span>
<span class="sd">		This field reads one line per sample. The line must be an integer.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_FieldContent&quot;</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_DenseLabelContent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_get_setting_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocabs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">dumps</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
	
	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		The function will return a dict, containing:</span>

<span class="s2">		* ``FIELDNAME`` (``np.ndarray[batch_size]``):</span>
<span class="s2">		  Labels of corresponding batched data.</span>

<span class="s2">		where</span>

<span class="s2">		* ``FIELDNAME`` is the name of the field.</span>
<span class="s2">	&quot;&quot;&quot;</span>
	
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		Examples:</span>
<span class="s2">			&gt;&gt;&gt; # 	data = {&#39;label&#39;: [1, 0]}</span>
<span class="s2">			&gt;&gt;&gt; field.get_batch(&#39;label&#39;, data, [0, 1])</span>
<span class="s2">			{</span>
<span class="s2">				&#39;label&#39;: numpy.array([1, 0])</span>
<span class="s2">			}</span>
<span class="s2">		&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DenseLabel.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.DenseLabel.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">ids</span><span class="p">}</span></div></div>


<span class="k">class</span> <span class="nc">_DenseLabelContent</span><span class="p">(</span><span class="n">_FieldContent</span><span class="p">):</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">DenseLabel</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_get_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
		<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read the next label and returns a 2-tuple (the next label(integer) and the number of elements it reads).</span>
<span class="sd">		Each element in `dataset` represents a label.</span>
<span class="sd">		Note that it may raise StopIteration.</span>

<span class="sd">		Arguments:{_FieldContent._GET_NEXT_ARG}</span>

<span class="sd">		Examples:</span>
<span class="sd">			&gt;&gt;&gt; dataset = iter([&quot;1\n&quot;, &quot;0\n&quot;])</span>
<span class="sd">			&gt;&gt;&gt; field = &quot;DenseLabel&quot;  # For simplicity, field is a string rather than a DenseLabel object.</span>
<span class="sd">			&gt;&gt;&gt; field_content = _DenseLabelContent(field)</span>
<span class="sd">			&gt;&gt;&gt; field_content.read_next(dataset)</span>
<span class="sd">			(1, 1)</span>
<span class="sd">			&gt;&gt;&gt; field_content.read_next(dataset)</span>
<span class="sd">			(0, 1)</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
		<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">),</span> <span class="mi">1</span>

	<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">}</span>

	<span class="k">def</span> <span class="nf">process_before_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">raw_data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">:</span>
			<span class="n">raw_data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span> <span class="o">=</span> <span class="n">raw_data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>


<div class="viewcode-block" id="SparseLabel"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SparseLabel">[docs]</a><span class="k">class</span> <span class="nc">SparseLabel</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Bases: :class:`.dataloader.Field`</span>

<span class="sd">	A field of categorical labels whose values are strings or sparse integer.</span>

<span class="sd">	See :class:`.dataloader.DenseLabel` for labels in dense integers.</span>

<span class="sd">	{NOT_SPECIFIED_DOCS}</span>

<span class="sd">	Arguments:</span>

<span class="sd">		vocab (:class:`SimpleVocab`, optional): The vocab to store all the labels.</span>
<span class="sd">			If ``None``, a :class:`SimpleVocab` is automatically created.</span>

<span class="sd">	Input Format</span>
<span class="sd">		This field reads one line per sample. The line can be an arbitary string.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocab</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SimpleVocab</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
		<span class="k">with</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">vocab</span><span class="o">=</span><span class="n">vocab</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">vocab</span> <span class="o">=</span> <span class="n">FieldContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vocab&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="n">SimpleVocab</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;vocab for SparseLabel must be a SimpleVocab object.&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vocab</span><span class="p">]:</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocab</span>

	<span class="n">_GET_BATCH_DATA_DOCSTRING</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;data (Dict[str, Any]): the object returned by :meth:`_SparseLabelContent.get_data`.</span>
<span class="s1">	 	data[&#39;str&#39;] is raw labels.</span>
<span class="s1">		data[&#39;id&#39;] is ids of labels.</span>
<span class="s1">	&#39;&#39;&#39;</span>
	
	<span class="n">_GET_BATCH_RETURN_VALUE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		The function will return a dict, containing:</span>

<span class="s2">		* ``FIELDNAME_id`` (``np.ndarray[batch_size]``):</span>
<span class="s2">		  Ids of corresponding labels.</span>
<span class="s2">		* ``FIELDNAME_str`` (``List[str]``):</span>
<span class="s2">		  Raw labels of the batched data.</span>

<span class="s2">		where</span>

<span class="s2">		* ``FIELDNAME`` is the name of the field.</span>
<span class="s2">	&quot;&quot;&quot;</span>
	
	<span class="n">_GET_BATCH_EXAMPLE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">		Examples:</span>
<span class="s2">			&gt;&gt;&gt; #	data = {</span>
<span class="s2">			&gt;&gt;&gt; #		&#39;id&#39;: [0, 2, 1, 0],</span>
<span class="s2">			&gt;&gt;&gt; #		&#39;str&#39;: [&#39;Java&#39;, &#39;Python&#39;, &#39;Cpp&#39;, &#39;Java&#39;]</span>
<span class="s2">			&gt;&gt;&gt; #	}</span>
<span class="s2">			&gt;&gt;&gt; field.get_batch(&#39;label&#39;, data, [0, 1])</span>
<span class="s2">			{</span>
<span class="s2">				&#39;label_id&#39;: numpy.array([0, 2]),  # Ids of corresponding labels.</span>
<span class="s2">				&#39;label_str&#39;: [&#39;Java&#39;, &#39;Python&#39;]   # Raw labels.</span>
<span class="s2">			}</span>
<span class="s2">	&quot;&quot;&quot;</span>
<div class="viewcode-block" id="SparseLabel.get_batch"><a class="viewcode-back" href="../../../dataloader.html#cotk.dataloader.SparseLabel.get_batch">[docs]</a>	<span class="k">def</span> <span class="nf">get_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">,</span>
			<span class="n">name</span> <span class="o">+</span><span class="s2">&quot;_str&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
		<span class="p">}</span></div>

	<span class="k">def</span> <span class="nf">_get_setting_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocabs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">dumps</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_FieldContent&quot;</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_SparseLabelContent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_SparseLabelContent</span><span class="p">(</span><span class="n">_FieldContent</span><span class="p">):</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">SparseLabel</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>

	<span class="k">def</span> <span class="nf">_get_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
		<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read the next label and returns a 2-tuple (the next label(string) and the number of elements it reads).</span>
<span class="sd">		Each element in `dataset` represents a label.</span>
<span class="sd">		Note that it may raise StopIteration.</span>

<span class="sd">		Arguments:{_FieldContent._GET_NEXT_ARG}</span>

<span class="sd">		Examples:</span>
<span class="sd">			&gt;&gt;&gt; dataset = iter([&quot;Java\n&quot;, &quot;Python\n&quot;, &quot;Cpp\n&quot;, &quot;Java\n&quot;])</span>
<span class="sd">			&gt;&gt;&gt; field_content = _SparseLabelContent()</span>
<span class="sd">			&gt;&gt;&gt; field_content.read_next(dataset)</span>
<span class="sd">			(&#39;Java&#39;, 1)</span>
<span class="sd">			&gt;&gt;&gt; field_content.read_next(dataset)</span>
<span class="sd">			(&#39;Python&#39;, 1)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
		<span class="k">return</span> <span class="n">label</span><span class="p">,</span> <span class="mi">1</span>

	<span class="k">def</span> <span class="nf">process_before_vocab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">raw_data_hash</span> <span class="o">=</span> <span class="n">UnorderedSha256</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">:</span>
			<span class="n">raw_data_hash</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_data_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_data_hash</span> <span class="o">=</span> <span class="n">raw_data_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">get_vocab</span><span class="p">()</span><span class="o">.</span><span class="n">add_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
		<span class="n">id_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">get_vocab</span><span class="p">()</span><span class="o">.</span><span class="n">convert_tokens_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">id_data</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_data</span><span class="p">}</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, thu-coai

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>